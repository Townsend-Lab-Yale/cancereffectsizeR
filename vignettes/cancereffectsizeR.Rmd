---
title: "Getting started"
---

Once you have installed cancereffectsizeR, you need a somatic mutation text file covering your samples in [MAF format](https://docs.gdc.cancer.gov/Data/File_Formats/MAF_Format). If you want to try out the software with publicly-available data, you can download MAFs covering collections of tumors from many cancer types from the TCGA data portal.

### Install reference data
Before running for the first time, you need to install a reference data set, or _refset_. Currently, a refset supporting the hg19 genome build is available as a separate data package. Install like this:

```{r eval = FALSE}
remotes::install_github("Townsend-Lab-Yale/ces.refset.hg19@*release")
```

Refsets for more genome builds and species may be added in the future; please let us know if you're interested. It's also possible to [build your own custom refset](custom_refset_instructions.html).

### MAF pre-processing
You want to be confident that the mutations in your MAF file are real. The presence of sequencing or calling error in your data will depend on your data sources and the quality of your pipeline, but here are a few filtering suggestions:

* There should be few to no mutations at sites where population databases show common germline variation.
* There should be few to no mutations in repetitive or poorly mapped regions of the genome, as mutations in these sites are difficult to call confidently and should be rare anyways since these regions are usually not functionally important at the small-variant level. Consider filtering out all variants at sites marked repetitive by RepeatMasker; this information is available on the UCSC Genome Browser.
* When combining data from multiple sources, look out for re-use of samples.

Once you have a high-confidence set of variants, **do not** filter out records based on silent mutation status or other functional criteria. cancereffectsizeR needs the full set of high-confidence mutations from all samples. (A note on indels: It's better to leave indels in the data if they're present, but it's okay if they're missing.)


### Create CESAnalysis
Begin by declaring your CESAnalysis object, the primary data structure of cancereffectsizeR. A CESAnalysis always
has an associated _refset_. Optionally, you can also define a set of sample groupings, if you want to be able to run future steps with different parameter choices for each group of samples. For example, if you will want to calculate gene mutation rates separately for sample subsets A and B, and run signature analysis separately for subsets 1, 2, and 3, then you may need to define six groups to account for all combinations: A1, A2, A3, B1, B2, B3.
```R
  # Create CESAnalysis with default reference data set (ces.refset.hg19)
  cesa = CESAnalysis()
  
  # Same, but with pre-defined sample groups (specific to the data/experiment)
  cesa = CESAnalysis(sample_groups = c("smoking", "nonsmoking"))
  
  # Same, but with sample groups that arguably have an evolutionary ordering. The order
  # used to define sample_groups doesn't matter; you'll specify the order later.
  # (Keep in mind that only 1 sample per individual can be included in analysis.)
  cesa = CESAnalysis(sample_groups = c("early", "stage3", "stage4"))
  
```

### Load MAF data
Next, use `load_maf()` to load [MAF](https://docs.gdc.cancer.gov/Data/File_Formats/MAF_Format/#gdc-maf-format-v100) data from a text file or a data table into a CESAnalysis object. If column names don't match MAF format specifications, you can supply your own column names. The only required columns are those specifying chromosome, position, reference and tumor alleles, and sample ID (Tumor_Sample_Barcode, by default); any other columns in your data will be ignored. If your CESAnalyses specifies sample groups (see Create CESAnalysis, above), also specify `group_col`.

#### Sequencing data coverage
By default, data is assumed to be derived from whole-exome sequencing. Whole-genome data and targeted sequencing data are also supported when the `coverage` option is specified. For targeted sequencing data, you must provide the set of target regions as a BED file or GRanges object. You can (and should) also supply this information for exome data, if you have it available. See ?load_maf() for details.

#### LiftOver support
If the MAF data you are loading is from a different genome build than your CESAnalysis, you can use the `chain_file` option to supply a UCSC-style chain file, and then your MAF coordinates will be automatically converted with liftOver.

#### Examples

```R
  ## Example 1
  cesa = CESAnalysis(refset = "ces.refset.hg19")
  
  # load in some whole-exome MAF data
  cesa = load_maf(cesa, maf = "wes_lung_adenocarcinoma.maf")
  
  # add some whole-genome data (and lift from hg38 to hg19 with a user-provided chain file)
  cesa = load_maf(cesa, maf = "wgs_luad.maf", coverage = "genome", chain_file = "hg38ToHg19.over.chain")
  
  # Add some targeted gene sequencing data, supplying a name for the coverage intervals (targeted regions)
  cesa = load_maf(cesa, maf = "cancer-gene-targeted_luad.maf", coverage = "targeted", 
                      covered_regions = "my_target_regions.bed", covered_regions_name = "TGS1")
  
  
  ## Example 2
  # Create a CESAnalysis with samples divided into tumor stage groups
  cesa = CESAnalysis(refset = "ces.refset.hg19", sample_groups = 1:4)
  
  # Load exome data with known target regions (should be available whenever the exome capture kit is known)
  # Also supplying some interval padding to allow variant calls with 100bp of the covered intervals.
  cesa = load_maf(cesa, maf = "my_multistage.maf", group_col = "stage",
                  coverage = "exome", covered_regions = "my_exome_targets.bed", 
                  covered_regions_name = "my_exome", covered_regions_padding = 100)
```


### Calculate mutation rates and estimate selection
After loading in data, run the following functions to prepare for calculation of cancer effect size. See each function's documentation for details.

* `trinuc_mutation_rates()` uses deconstructSigs to extract mutational signature weightings from each tumor's SNV mutation profile, and from there calculates trinucleotide-context-specific SNV mutation rates. See also `vignette("cosmic_cancer_type_note")` for advice on excluding certain signatures that may be presumed absent from your tumors. 
* `gene_mutation_rates()` uses dNdScv to calculate gene-level mutation rates. It's highly recommended to supply tissue-specific covariate data if available. Covariates for many human tissue types are included in `ces.refset.hg19`. You can also use the default hg19 covariates from dNdScv.

If you have defined `sample_groups` in your CESAnalysis, you can call each of these functions multiple times, specifying one or more sample groups per run. 

```
  # Create CESAnalysis object and define chronological tumor progression states
  analysis = CESAnalysis(refset = "ces.refset.hg19", sample_groups = c("Primary", "Metastatic"))
  analysis = load_maf(analysis, maf = "luad_data.maf", group_col = "pri_met")
  
  # Before running trinuc_mutation_rates, which includes a mutational signature analysis,
  # you can run this function to identify possible signatures to exclude. It's recommended
  # to manually review the suggestions and decide which signatures to exclude.
  #
  # Here, we decide to accept all suggestions, so we assign the output of the function
  # (a vector of signatures to exclude) to to_remove.
  to_remove = suggest_cosmic_signatures_to_remove(cancer_type = "LUAD", treatment_naive = T)
  
  
  analysis = trinuc_mutation_rates(analysis, signature_set = "COSMIC_v3.1", signatures_to_remove = to_remove)
  
  # calculate neutral gene mutation rates within groups, since group differences are likely
  analysis = gene_mutation_rates(analysis, covariates = "lung", sample_group = "Primary")
  analysis = gene_mutation_rates(analysis, covariates = "lung", sample_group = "Metastatic")
```

Once all rates have been calculated, you are ready to run `ces_variant()` to find effect sizes under a model of selection. 
There are two built-in models. _sswm_ and _sswm_sequential_. (SSWM stands for the "strong selection, weak mutation" assumption of these models. See our [paper](https://doi.org/10.1093/jnci/djy168) for details.) The default model, _sswm_, assumes that each variant has a consistent selection intensity across all samples being tested. _sswm_sequential_ assumes that selection intensity varies among sample groups that are (presumably) in sequential states of disease progression. Naturally, this model can only be used if you have defined sample groups, and if those groups can be thought of as sequential. The group ordering is defined in the call to `ces_variant`. In this example, primary and metastatic samples are sequential, so we can use _sswm_sequential_. However, it's still worth running the default model, because the rarity of even common driver mutations is such that dividing data into subgroups will result in losing some useful information.

By default, all variants with frequency >1 will be tested for selection. You can specify precisely which variants to include (and, if you like, include all variants) using the `select_variants()` function.
```{r eval = F}
  # Calculate effect sizes under SSWM model (by default, on all variants with frequency > 1 in the MAF data)
  # supplying optional run names for clarity
  analysis = ces_variant(cesa = analysis, run_name = "general")


  # Calculate stage-specific effects under sequential model
  analysis = ces_variant(cesa = analysis, model = "sswm_sequential", 
                         groups = list("Primary", "Metastatic"), run_name = "stage_specific")
```

To visualize highly selected variants from selection output, use `lollipops()`:
```{r eval = F}
  # Examine SIs from three major drivers in the general selection output
  si = analysis$selection$general
  gene_tables = list(KRAS = si[gene == "KRAS"], EGFR = si[gene == "EGFR"], TP53 = si[gene == "TP53"])
  lollipops(gene_tables, max_sites = 20)
```

![(not real data)](kras_egfr_tp53.jpg)

We can also visualize selection intensities from the _sswm_sequential_ model:
```{r eval = F}
  # Show early/late SIs of high-frequency variants
  # Setting a selection floor ensures variants with frequency of zero in either group don't appear
  si = analysis$selection$stage_specific[si_Primary > 1 & si_Metastatic > 1]
  lollipops(si, group_names = c("Early", "Late"))
```

![(not real data)](primary_met_lollipops.jpg)


### Going further
Use the `select_variants()` function to find variants in your data and view cancereffectsizeR's annotations. You can use this function to collect variants for input into `ces_variant`.

In addition to testing for selection of single variants, you can test epistatic models of selection at the variant and gene levels using `ces_epistasis()` and `ces_gene_epistasis()`. Output can identify cases of both positive epistasis and mutual exclusivity. There is also support for testing custom models of selection in `ces_variant()`; see the function's documentation for details.

It's sometimes helpful to combine sets of variants, based on genomic position or functional hypotheses, into batches that can be tested in selection functions as if they were single variants. (The simplifying assumption is that all samples with any mutation in the batch experience similar effects.) We call these _compound variants_, and you can use them with `ces_variant` and `ces_epistasis`. See `?define_compound_variants` for details.
