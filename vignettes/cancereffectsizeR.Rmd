---
title: "Tutorial"
output:
  html_document:
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, tidy = 'styler')
```

Welcome to cancereffectsizeR! This tutorial walks you through some of the package's key features to analyze publicly-available tumor sequencing data. We recommend that you start a fresh R/RStudio session. You can follow along by copy-and-pasting code into an R script (or the console, but it's nice to be able to save the finished product).

## Installation and quickstart
If you haven't installed the package already, or if it's been a while since installation, run this to install the latest release:
```{r}
# Some dependencies are large, so we increase the download time limit to be safe
options(timeout = 600) 
install.packages('remotes')
remotes::install_github("Townsend-Lab-Yale/cancereffectsizeR@*release")
```


In addition to installing cancereffectsizeR, you need to install a reference data set, or _refset_. These refsets include genomic and gene annotations, mutational signature definitions, and more. Currently, refsets supporting the hg38 and hg19 builds of the human genome are available as separate data packages. (If you want to build your own refset to use a custom genome build or gene set for almost any species, [you can](custom_refset_instructions.html).) For this tutorial, we'll use the hg38 refset package.
```{r}
options(timeout = 600)
remotes::install_github("Townsend-Lab-Yale/ces.refset.hg38@*release")
```


Before continuing, you may want to create a directory for this tutorial to store all the data and output in one place.
```{r}
# setwd() somewhere, if desired
dir.create('CES_tutorial')
setwd('CES_tutorial')
```


### Quickstart
If you want to skip all the details and run through a full, no-frills cancereffectsizeR analysis, see below. Otherwise, take a peek to get a sense of what's to come, or keep reading for a more thorough walkthrough.
<details><summary>(Show/hide quickstart)</summary>
```{r}
library(cancereffectsizR)
library(data.table)

# Download breast cancer somatic variant data
tcga_maf_file = 'TCGA.BRCA.mutect.995c0111-d90b-4140-bee7-3845436c3b42.DR-10.0.somatic.maf.gz'
if (! file.exists(tcga_maf_file)) {
  download.file('https://api.gdc.cancer.gov/data/995c0111-d90b-4140-bee7-3845436c3b42', 
                destfile = tcga_maf_file)
}

# Prepare data and filter a few likely germline/false-positive calls
maf = preload_maf(maf = tcga_maf_file, refset = "ces.refset.hg38")
maf = maf[germline_variant_site == F][repetitive_region == F | cosmic_site_tier %in% 1:3]

# Create cancereffectsizeR analysis and load data
cesa = CESAnalysis(refset = "ces.refset.hg38")
cesa = load_maf(cesa = cesa, maf = maf)

# Infer trinculeotide-context-specific relative rates of SNV mutation from
# a mutational signature analysis (leaving out signatures not found in BRCA)
signature_exclusions = suggest_cosmic_signatures_to_remove(cancer_type = 'BRCA', treatment_naive = TRUE)
cesa = trinuc_mutation_rates(cesa = cesa, signature_set = ces.refset.hg38$signatures$COSMIC_v3.2, 
                             signature_exclusions = signature_exclusions)

# Estimate neutral gene mutation rates using dNdScv, with tissue-specific mutation rate covariates.
cesa = gene_mutation_rates(cesa, covariates = ces.refset.hg38$covariates$breast)

# Infer scaled selection coefficients under the default model of clonal selection.
# By default, inference is restricted to recurrent mutations.
cesa = ces_variant(cesa)

# Copy output, merge in variant annotations, and view top variants
selection = cesa$selection[[1]]
selection = selection[cesa$variants, on = 'variant_id', nomatch = NULL]
top = selection[order(-selection_intensity)][1:10]

# Plot top effects 
library(ggplot2)
library(ggrepel)
top[, x := 1:.N] # easiest to number the rows
top[, display_name := gsub('_', ' ', variant_name)]
ggplot(top, aes(x, selection_intensity)) + 
  geom_errorbar(aes(ymin = ci_low_95, ymax = ci_high_95), width = .2, color = 'darkgrey') +
  scale_x_discrete() + scale_y_log10() + 
  geom_point(aes(color = as.factor(maf_prevalence))) + 
  geom_label_repel(aes(label = display_name), nudge_y = -.1, min.segment.length = Inf) + 
  xlab("variant") + ylab("scaled selection coefficient (log10)") +
  ggtitle('Top cancer effects in TCGA BRCA') +
  guides(color = guide_legend(title = 'variant prevalence'))

# There's lots more that can be done with cancereffectsizR! See the full tutorial for some
# important details and a broader view of functionality.
```
</details>


## Preparing data
Load cancereffectsizeR, as well as the data.table package. cancereffectsizeR makes extensive use of data tables, so it's handy to have the package loaded to be able to take advantage of all data.table functionality.
```{r}
library(cancereffectsizeR)
library(data.table)

```


### TCGA data (whole-exome)
We'll begin by downloading somatic variant data from the TCGA BRCA (breast carcinoma) project. The data comes in a large text file listing somatic mutations for a collection of tumors, in accordance with [MAF format](https://docs.gdc.cancer.gov/Data/File_Formats/MAF_Format). 
```{r}
tcga_maf_file = 'TCGA.BRCA.mutect.995c0111-d90b-4140-bee7-3845436c3b42.DR-10.0.somatic.maf.gz'
if (! file.exists(tcga_maf_file)) {
  download.file('https://api.gdc.cancer.gov/data/995c0111-d90b-4140-bee7-3845436c3b42', destfile = tcga_maf_file)
}
```


Let's also load and examine a table of patient information. Although the TCGA samples in the data set are all taken from primary tumors, you'll see that some patients presented with metastatic disease (pM = M1). Hormone receptor status (progesterone or estrogen receptor positive) and HER2 amplification status are also recorded in a combined column.
```{r}
tcga_clinical = fread(system.file("tutorial/TCGA_BRCA_clinical.txt", package = "cancereffectsizeR"))
tcga_clinical[1:5]
```

The `preload_maf()` takes in MAF data, finds the columns needed by cancereffectsizeR, adds a couple of genomic annotations, and checks for common problems. Since TCGA data sets are well-curated, this particular run will not reveal any problems. This MAF file already uses the hg38 genome build, but if it didn't, we could use the `chain_file` argument to convert records via liftOver.
```{r}
tcga_maf = preload_maf(maf = tcga_maf_file, refset = "ces.refset.hg38")
```
If you compare the TCGA MAF and clinical file, you'll see we have a small problem: the clinical file uses patient IDs, while the MAF uses tissue sample IDs. (This column was originally called Tumor_Sample_Barcode, but `preload_maf()` changed it to Unique_Patient_Identifier. cancereffectsizeR uses this column name to emphasize the point that all MAF samples must derive from distinct patients.)

Luckily, TCGA IDs are easy to convert. After verifying that each TCGA patient has just one sample in the MAF data, we'll change tissue IDs to patient IDs.
```{r}
# TCGA sample IDs start with the patient ID, luckily. Verify a 1-1 sample-patient
# relationship. If this check failed, we would need to figure out a sample exclusion
# strategy before proceeding with analysis.
tcga_maf[, patient_id := substr(Unique_Patient_Identifier, 1, 12)]
uniqueN(tcga_samples[, .(patient_id, Unique_Patient_Identifier)]) == uniqueN(tcga_samples$Unique_Patient_Identifier)

# We can now use patient_id as the unique identifier.
tcga_maf[, Unique_Patient_Identifier := patient_id]
tcga_maf[, patient_id := NULL] # remove redundant column
```



### Pre-analysis variant filtering
Since our goal is to quantify somatic selection, we want the MAF data to represent a complete set of high-confidence somatic variants from the samples. It's probably unwise to go too far down the rabbithole of second-guessing the variant calling methods used in the data sources. However, there is some simple filtering that we often use to bring the data into alignment with these tenets:
* There should be few to no mutations at sites where population databases show common germline variation.
* There should be few to no mutations in repetitive or poorly mapped regions of the genome, as mutations in these sites are difficult to sequence confidently, and they should be rare anyway since these regions are usually not functionally important at the small-variant level.
* Samples should have little mutational overlap, especially at sites without known cancer association.

When using ces.refset.hg38 (hg38), the preloaded MAF has three relevant annotation columns:
* germline_variant_site: The variant overlaps a region that contains a common germline variant according to gnomAD (common being >1% prevalence in some population).
* repetitive_region: The variant is in a region of the genome marked as repetitive by the RepeatMasker tool.
* cosmic_site_tier: Indicates if the variant overlaps a site annotated as cancer-related (tiers 1, 2, and 3) by COSMIC. 

We suggest filtering out all germline site records, as well as records from repetive regions except for the few with COSMIC annotations. We can apply this filtering like this:
```{r}
tcga_maf = tcga_maf[germline_variant_site == F]
tcga_maf = tcga_maf[repetitive_region == F | cosmic_site_tier %in% 1:3]
```

When combining data sources, or using data from projects that sequenced multiple samples per patient, it's important to verify that only one sample per patient is included in your MAF (and in your downstream cancereffectsizeR analysis), since samples from the same patient likely did not evolve independently. Since it's often hard to be sure that there wasn't re-use of samples across different data sources, we recommend both careful manual curation and the use of `check_sample_overlap()` to catch unexpected sample duplication.


#### What not to filter
To get a complete picture of the mutational processes present in tissues, variants should not be filtered on any sort of functional criteria. One thing to watch out for: Occasionally, researchers will leave out synonymous variants when publishing their study data. As synonymous variants are essential for calculating gene mutation rates, the synonymous variants should be tracked down before using the data.

#### Notes on data sources
* While TCGA data is whole-exome, cancereffectsizeR can also incorporate whole-genome and targeted sequencing data from multiple sources into a single analysis.
* Targeted sequencing of known cancer genes is useful to increase sample size, with the caveat that at least one exome or genome data source must be included in the analysis, since targeted sequencing data can't be used for inferences of mutational processes or gene mutation rates. (There are too few mutations, typically, and since they're mostly in cancer hotspots, they don't provide a baseline of what mutation rates are like in the absence of selection.)

## Create CESAnalysis and load data
The CESAnalysis is the primary data structure of cancereffectsizeR. The cancereffectsizeR workflow consists of calling a series of functions that take a CESAnalysis as input and return an altered CESAnalysis. Re-using the same variable name will keep things tidy.

Let's create a CESAnalysis and call `load_maf()` to load the TCGA data.
```{r}
cesa = CESAnalysis(refset = "ces.refset.hg38")
cesa = load_maf(cesa = cesa, maf = tcga_maf)
```

You will see a message that some variants fall outside of the refset's exome definitions. Since we don't know exactly what exome capture techniques were used for the BRCA project (probably a combination of multiple kits at different study sites), this isn't unexpected. (On the off chance that you do know the exact exome capture intervals of whatever data you're using, you should supply those intervals with load_maf()'s covered_regions argument.)

To navigate a CESAnalysis, use the dollar sign ($). We can use these accessors to look at the MAF data as well more detailed variant annotations, and if we want we can perform various filtering operations, such as identifying the most prevalent variants.
```{r}
cesa$maf
cesa$variants
cesa$samples

# Let's see the top variants
(top_variants = cesa$variants[order(-maf_prevalence)][1:10, .(variant_name, chr, start, end, maf_prevalence)])
```

Let's load the clinical data into the analysis, too.
```{r}
cesa = load_sample_data(cesa, tcga_clinical)
```

Now that we've loaded the sample data, we can, for example, see how variant counts break down across different sample groups. Let's see a breakdown PIK3CA mutation status by BRCA receptor phenotype.
```{r}
# Get samples with 1 or more PIK3CA mutation
samples_with_pik3ca = cesa$maf[top_gene == "PIK3CA", unique(Unique_Patient_Identifier)]
pik3ca_sample_counts = cesa$samples[samples_with_pik3ca, .(with_PIK3CA = .N),
                                    by = 'receptor_status', on = 'Unique_Patient_Identifier']
total_sample_counts = cesa$samples[, .N, by = 'receptor_status']
combined_counts = merge.data.table(pik3ca_sample_counts, total_sample_counts, by = 'receptor_status')
combined_counts[, freq := with_PIK3CA / N]
combined_counts
```
PIK3CA mutation is least prevalent in triple negative breast cancer.

We can also look at variant prevalence by metastatic disease status. By default, the `variant_counts` function considers all mutations, but we'll subset to recurrent mutations.
```{r}
counts_by_M = variant_counts(cesa = cesa, variant_ids = cesa$variants[maf_prevalence > 1, variant_id],
                             by = 'pM')

counts_by_M[M1_prevalence > 0][order(-M1_prevalence)]
```

## Relative trinucleotide rate calculation

```{r}

```


