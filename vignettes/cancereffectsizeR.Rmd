---
title: "Tutorial"
output:
  html_document:
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, tidy = 'styler')
library(data.table)
library(ggplot2)
```

Welcome to cancereffectsizeR! This tutorial walks you through some of the package's key features to analyze publicly-available tumor sequencing data. We recommend that you start a fresh R/RStudio session. You can follow along by copy-and-pasting code into an R script.

## Installation and quickstart
If you haven't installed the package yet, or if it's been a while, install the latest release:
```{r}
# Some dependencies are large, so we increase the download time limit to be safe
options(timeout = 600) 
install.packages('remotes')
remotes::install_github("Townsend-Lab-Yale/cancereffectsizeR@*release", dependencies = TRUE)
```

Regrettably, there is a bug in some older versions of the GenomeInfoDb package that may produce cryptic error messages in cancereffectsizeR, along the lines of `!anyNA(m32) is not TRUE`. If you encounter this issue, the simplest solution is to update your Bioconductor version:

```{R}
# Only necessary if the current Bioconductor version is <3.14.
if (BiocManager::version() < as.package_version("3.14")) {
  BiocManager::install(version = "3.14")
}
```

In addition to installing cancereffectsizeR, you need to install a reference data set, or _refset_. These refsets include genomic and gene annotations, mutational signature definitions, and more. Currently, refsets supporting the hg38 and hg19 builds of the human genome are available as separate data packages. (If you want to build your own refset to use a custom genome build or gene set for almost any species, [you can](custom_refset_instructions.html).) For this tutorial, we'll use the hg38 refset package.
```{r}
options(timeout = 600)
remotes::install_github("Townsend-Lab-Yale/ces.refset.hg38@*release")
```

Before continuing, you may want to create a directory for this tutorial to store all the data and output in one place.
```{r}
# setwd() somewhere, if desired
dir.create('CES_tutorial')
setwd('CES_tutorial')
```


### Quickstart
If you want to skip all the details and run through a no-frills cancereffectsizeR analysis now, see below. Otherwise, take a peek to get a sense of what's to come, or keep reading for a more thorough walkthrough.
<details><summary>(Show/hide quickstart)</summary>
```{r}
library(cancereffectsizeR)
library(data.table)

# Download breast cancer somatic variant data
tcga_maf_file = 'TCGA.BRCA.mutect.995c0111-d90b-4140-bee7-3845436c3b42.DR-10.0.somatic.maf.gz'
if (! file.exists(tcga_maf_file)) {
  download.file('https://api.gdc.cancer.gov/data/995c0111-d90b-4140-bee7-3845436c3b42', 
                destfile = tcga_maf_file)
}

# Prepare data and filter a few likely germline/false-positive calls
maf = preload_maf(maf = tcga_maf_file, refset = "ces.refset.hg38")
maf = maf[germline_variant_site == F][repetitive_region == F | cosmic_site_tier %in% 1:3]

# Create cancereffectsizeR analysis and load data
cesa = CESAnalysis(refset = "ces.refset.hg38")
cesa = load_maf(cesa = cesa, maf = maf)

# Infer trinculeotide-context-specific relative rates of SNV mutation from
# a mutational signature analysis (leaving out signatures not found in BRCA)
signature_exclusions = suggest_cosmic_signatures_to_remove(cancer_type = 'BRCA', treatment_naive = TRUE)
cesa = trinuc_mutation_rates(cesa = cesa, signature_set = ces.refset.hg38$signatures$COSMIC_v3.2,
                             signature_exclusions = signature_exclusions)

# Estimate neutral gene mutation rates using dNdScv, with tissue-specific mutation rate covariates.
cesa = gene_mutation_rates(cesa, covariates = ces.refset.hg38$covariates$breast)

# Infer scaled selection coefficients under the default model of clonal selection.
# By default, inference is restricted to recurrent mutations.
cesa = ces_variant(cesa)

# Copy output, merge in variant annotations, and view top variants
selection = cesa$selection[[1]]
selection = selection[cesa$variants, on = 'variant_id', nomatch = NULL]
top = selection[order(-selection_intensity)][1:10]

# Plot top effects 
library(ggplot2)
library(ggrepel)
ggplot(top, aes(display_levels, selection_intensity)) + 
  geom_errorbar(aes(ymin = ci_low_95, ymax = ci_high_95), width = .2, color = 'darkgrey') +
  scale_x_discrete() + scale_y_log10() +
  geom_point(aes(color = as.factor(maf_prevalence)), size = 2.5) + 
  xlab("variant") + ylab(expression('cancer effect'~scriptstyle(~~(log[10])))) +
  ggtitle('Top cancer effects in TCGA BRCA') +
  guides(color = guide_legend(title = 'variant prevalence')) + 
  theme_minimal() + theme(legend.position = 'bottom', text = element_text(family = "Arial"),
                          axis.text.x = element_text(size = 8, family = "Verdana"))

# There's lots more that can be done with cancereffectsizeR! See the full tutorial for some
# important details and a broader view of functionality.
```

```{r echo = F, eval = T}
top = fread(system.file("tutorial/top_BRCA_effects.txt", package = 'cancereffectsizeR')) 
top[, display_levels := factor(display_name, levels = display_name, ordered = T)] # re-establish factor
ggplot(top, aes(display_levels, selection_intensity)) + 
  geom_errorbar(aes(ymin = ci_low_95, ymax = ci_high_95), width = .2, color = 'darkgrey') +
  scale_x_discrete() + scale_y_log10() +
  geom_point(aes(color = as.factor(maf_prevalence)), size = 2.5) + 
  xlab("variant") + ylab(expression('cancer effect'~scriptstyle(~~(log[10])))) +
  ggtitle('Top cancer effects in TCGA BRCA') +
  guides(color = guide_legend(title = 'variant prevalence')) + 
  theme_minimal() + theme(legend.position = 'bottom', text = element_text(family = "Arial"),
                          axis.text.x = element_text(size = 8, family = "Verdana"))
```

</details>


## Preparing data
Load cancereffectsizeR, as well as the data.table package. cancereffectsizeR makes extensive use of data tables, so it's handy to have the package loaded.
```{r}
library(cancereffectsizeR)
library(data.table)
```

For this tutorial, we'll use somatic variant data produced from exome sequencing by the TCGA BRCA (breast carcinoma) project. We will supplement this with targeted sequencing data from the Metastatic Breast Cancer data set [hosted at cBioPortal](https://www.cbioportal.org/study/summary?id=breast_ink4_msk_2021). (We stop at two data sources for brevity; for the best possible analysis of somatic selection, we would want to include as many data sources as we could find.)

In cancereffectsizeR, data can be combined from multiple whole-exome, whole-genome, and targeted sequencing sources, although we always need at least one source of whole-exome or whole-genome data to anchor the analysis. Targeted sequencing data can't be used for mutation rate inference: there are too few mutations, typically, and since they're mostly in cancer hotspots, they don't provide a baseline of what mutation rates are like in the absence of selection. Instead, mutation rates in TGS samples will be assumed to be similar to those calculated in WXS/WGS samples.


### TCGA data (whole-exome)
We'll begin by downloading variant data from TCGA. The data comes in a large text file listing somatic mutations for a collection of tumors, in accordance with [MAF format](https://docs.gdc.cancer.gov/Data/File_Formats/MAF_Format). 
```{r}
tcga_maf_file = 'TCGA.BRCA.mutect.995c0111-d90b-4140-bee7-3845436c3b42.DR-10.0.somatic.maf.gz'
if (! file.exists(tcga_maf_file)) {
  download.file('https://api.gdc.cancer.gov/data/995c0111-d90b-4140-bee7-3845436c3b42', destfile = tcga_maf_file)
}
```


Let's also load and examine a table of patient information. Although the TCGA samples in the data set are all taken from primary tumors, you'll see that some patients presented with metastatic disease (pM = M1). Hormone receptor status (progesterone or estrogen receptor positive) and HER2 amplification status are also recorded in a combined column.
```{r eval = T}
tcga_clinical = fread(system.file("tutorial/TCGA_BRCA_clinical.txt", package = "cancereffectsizeR"))
tcga_clinical[1:5]
```

The `preload_maf()` function takes in MAF data, finds the columns needed by cancereffectsizeR, adds a couple of genomic annotations, and checks for common problems. Since TCGA data sets are well-curated, this particular run will not reveal any problems. This MAF file already uses the hg38 genome build, but if it didn't, we could use the `chain_file` argument to convert records via liftOver.
```{r}
tcga_maf = preload_maf(maf = tcga_maf_file, refset = "ces.refset.hg38")
```
If you compare the TCGA MAF and clinical file, you'll see we have a small problem: the clinical file uses patient IDs, while the MAF uses tissue sample IDs. (This column was originally called Tumor_Sample_Barcode, but `preload_maf()` changed it to Unique_Patient_Identifier. cancereffectsizeR uses this column name to emphasize that all MAF samples must derive from distinct patients.)

Luckily, TCGA IDs are easy to convert. After verifying that each TCGA patient has just one sample in the MAF data, we'll change tissue IDs to patient IDs.
```{r}
# TCGA sample IDs start with the patient ID, luckily. Here, we verify a 1-1 sample-patient
# relationship. If this check failed, we would need to figure out a sample exclusion
# strategy before proceeding with analysis.
tcga_maf[, patient_id := substr(Unique_Patient_Identifier, 1, 12)]
uniqueN(tcga_maf[, .(patient_id, Unique_Patient_Identifier)]) == uniqueN(tcga_maf$Unique_Patient_Identifier)

# We can now use patient_id as the unique identifier.
tcga_maf[, Unique_Patient_Identifier := patient_id]
tcga_maf[, patient_id := NULL] # remove redundant column
setnames(tcga_clinical, "patient_id", "Unique_Patient_Identifier")
```

### Metastatic data (TGS)
Our TGS data source (hosted on cBioPortal and [recently published](https://cancerdiscovery.aacrjournals.org/content/candisc/early/2021/09/17/2159-8290.CD-20-1726.full.pdf) in Cancer Discovery), consists of metastatic tumors that were sequenced using various MSK-Impact panels. In the full data set, some patients have multiple samples sequenced; the data provided with the package has been subsetted to one sample per patient, and the genome build has been converted to hg38.
```{r}
tgs_maf_file = system.file('tutorial/metastatic_breast_2021_hg38.maf', package = 'cancereffectsizeR')
tgs_maf = preload_maf(maf = maf_file, refset = ces.refset.hg38)
```

### Pre-analysis variant filtering
<details><summary>(Show/hide justification)</summary>
Since our goal is to quantify somatic selection, we want the MAF data to represent a complete set of high-confidence somatic variants from the samples. It's probably unwise to go too far down the rabbithole of second-guessing the variant calling methods used in the data sources. However, there is some simple filtering that we often use to bring the data into alignment with these tenets:

* There should be few to no mutations at sites where population databases show common germline variation.
* There should be few to no mutations in repetitive or poorly mapped regions of the genome, as mutations in these sites are difficult to sequence confidently, and they should be rare anyway since these regions are usually not functionally important at the small-variant level.
* Samples should have little mutational overlap, especially at sites without known cancer association.

When using ces.refset.hg38 (hg38), the preloaded MAF has three relevant annotation columns:

* germline_variant_site: The variant overlaps a region that contains a common germline variant according to gnomAD (common being >1% prevalence in some population).
* repetitive_region: The variant is in a region of the genome marked as repetitive by the RepeatMasker tool.
* cosmic_site_tier: Indicates if the variant overlaps a site annotated as cancer-related (tiers 1, 2, and 3) by COSMIC. 
</details>

We suggest filtering out all germline site records, as well as records from repetitive regions except for the few with COSMIC annotations. We can apply this filtering like this:
```{r}
tcga_maf = tcga_maf[germline_variant_site == F]
tcga_maf = tcga_maf[repetitive_region == F | cosmic_site_tier %in% 1:3]
```

We don't apply these filters to TGS data, since it tends to be high-depth sequencing of cancer hotspots.

When combining data sources, or using data from projects that sequenced multiple samples per patient, it's important to verify that only one sample per patient is included in your MAF (and in your downstream cancereffectsizeR analysis), since samples from the same patient likely did not evolve independently. Since it's often hard to be sure that there isn't re-use of samples across different data sources, we recommend both careful manual curation and the use of `check_sample_overlap()` to catch unexpected sample duplication. (If you try it on `tcga_maf` and `tgs_maf`, you'll see that our data passes this check.)

#### What not to filter
To get a complete picture of the mutational processes present in tissues, whole-exome/whole-genome variants should not be filtered on any sort of functional criteria. One thing to watch out for: Occasionally, researchers will leave out synonymous variants when publishing their study data. As synonymous variants are essential for calculating gene mutation rates, the synonymous variants should be tracked down before using the data.

Since TGS data is not used to infer mutation rates, it's okay to filter TGS data to regions of interest. We are actually about to do this! We will have to take care to accurately report the coverage of the filtered data in the next step.

## Create CESAnalysis and load data
The CESAnalysis is the primary data structure of cancereffectsizeR. The cancereffectsizeR workflow consists of calling a series of functions that take a CESAnalysis as input and return an altered CESAnalysis. Re-using the same variable name will keep things tidy.

### Load WXS data
Let's create a CESAnalysis and call `load_maf()` to load the TCGA data.
```{r}
cesa = CESAnalysis(refset = "ces.refset.hg38")
cesa = load_maf(cesa = cesa, maf = tcga_maf)
```

You will see a message that some variants fall outside of the refset's exome definitions. Since we don't know exactly what exome capture techniques were used for the BRCA project (probably different methods at different study sites), this isn't unexpected. (On the off chance that you do know the exact exome capture intervals of whatever data you're using, you should supply those intervals with `load_maf()`'s `covered_regions` argument. For WGS data, simply set `coverage = "genome"`. We'll discuss how to load TGS data shortly.)

To navigate a CESAnalysis, use the dollar sign ($). We can use these accessors to look at the MAF data as well more detailed variant annotations, and if we want we can perform various filtering operations, such as identifying the most prevalent variants in the loaded data.
```{r}
cesa$maf
cesa$variants
cesa$samples

# Let's see the top variants
(top_variants = cesa$variants[order(-maf_prevalence)][1:10, .(variant_name, chr, start, end, maf_prevalence)])
```

Let's load the clinical data into the analysis, too.
```{r}
cesa = load_sample_data(cesa, tcga_clinical)
```

Now that we've loaded the sample data, we can, for example, see how variant counts break down across different sample groups. Let's see a breakdown PIK3CA mutation status by BRCA receptor phenotype.
```{r}
# Get samples with 1 or more PIK3CA mutation
samples_with_pik3ca = cesa$maf[top_gene == "PIK3CA", unique(Unique_Patient_Identifier)]
pik3ca_sample_counts = cesa$samples[samples_with_pik3ca, .(with_PIK3CA = .N),
                                    by = 'receptor_status', on = 'Unique_Patient_Identifier']
total_sample_counts = cesa$samples[, .N, by = 'receptor_status']
combined_counts = merge.data.table(pik3ca_sample_counts, total_sample_counts, by = 'receptor_status')
combined_counts[, freq := with_PIK3CA / N]
combined_counts
```
PIK3CA mutation is least prevalent in triple negative breast cancer.


### Load TGS data
To load our TGS data, we need to be able to define its coverage. Why? To estimate the selection of a mutation, we need to know which samples have the mutation, which samples do not, and which are unknown due to lack of sequencing coverage. Our TGS samples were sequenced with multiple panels covering different genes, and unfortunately, the exact coverage (defined by genomic coordinates) is not publicly available for all of these. Therefore, for simplicity, we will filter the TGS data to mutations at a handful of top cancer genes that are covered in all of the panels. When we load the data, all records outside of these genes will be excluded, leaving us with greater power to infer selection in these genes without impacting our estimates outside these genes, which will use just the TCGA data. (As mentioned earlier, we shouldn't filter WXS/WGS data this way, since it would interfere with mutation rate calculation, but TGS samples are not involved in mutation rate calculation.)

```{r}
# Define coverage using the coding regions of these genes, as defined by the refset
top_tgs_genes = c("TP53", "PIK3CA", "ESR1","CDH1","GATA3","KMT2C",
                      "MAP3K1","AKT1","ARID1A","FOXA1","TBX3","PTEN")
tgs_coverage = ces.refset.hg38$gr_genes[ces.refset.hg38$gr_genes$gene %in% top_tgs_genes]
```

We don't have a clinical file for the TGS data, but we do know that they're all metastatic samples. Instead of creating another table and calling `load_sample_data()`, we can use the `sample_data_cols` feature of load_maf():
```{r}
tgs_maf$pM = 'M1'
cesa = load_maf(cesa, maf = tgs_maf, sample_data_cols = 'pM', 
                coverage = 'targeted', covered_regions = tgs_coverage, covered_regions_name = 'top_genes')
```

Now that all the data is loaded, we'll show one data-wrangling example: Let's look at variant prevalence by metastatic disease status. By default, the `variant_counts()` function considers all mutations, but we'll subset to recurrent mutations.
```{r}
counts_by_M = variant_counts(cesa = cesa, variant_ids = cesa$variants[maf_prevalence > 1, variant_id],
                             by = 'pM')
counts_by_M[M1_prevalence > 0][order(-M1_prevalence)]
```

## Mutational processes and relative mutation rates
For each (exome) sample in our data set, `trinuc_mutation_rates()` will perform mutational signature extraction in order to to attribute each sample's set of SNVs to a linear combination of mutational processes. By default, the signature extraction is done using the `MutationalPatterns` package, and `deconstructSigs` is also supported. The signature attribution allows us to infer sample-specific relative rates of SNV mutation for all trinucleotide contexts. TGS samples will be assumed to have mutational processes matching the group-average mutational processes of the exome data. (This isn't optimal, since the metastatic samples may be affected by mutational processes, such as chemotherapy, that are lacking in the primary tumor exome data, but it might be the best we can do without finding another data source.)

We will use signature definitions from the refset (it's also possible to create your own). To improve the accuracy of signature extraction, we will exclude signatures that can safely be presumed absent from the samples; a helper function, `suggest_cosmic_signatures_to_remove()`, can provide some guidance.

```{r}
# We'll use all suggested exclusions (TCGA primary tumors are treatment-naive)
signature_exclusions = suggest_cosmic_signatures_to_remove(cancer_type = 'BRCA', treatment_naive = TRUE)

cesa = trinuc_mutation_rates(cesa, signature_set = ces.refset.hg38$signatures$COSMIC_v3.2, 
                             signature_exclusions = signature_exclusions)
```


The `trinuc_mutation_rates()` run has added some useful information to the CESAnalysis:
* **snv_counts**: A matrix of SNV counts by trinucleotide context. (You can also generate such a matrix from MAF data with `trinuc_snv_counts()`.)
* **raw_attributions**: Signature attributions as generated by the extractor. For MutationalPatterns, this matrix contains the number of mutations attributed to signature for each sample. Naturally, samples with more mutations will tend to have higher raw attributions.
* **biological_weights**: The proportion of mutations attributed to each biologically-associated signature within each sample. Mutations attributed to signatures associated with sequencing/processing artifacts are left out. (Technical detail: Due to the instability of signature attributions on samples with few mutations, Samples with few MAF variants have their weights adjusted towards group-average weights, as indicated in the `group_avg_blended` column. If you want to make claims about subgroup differences in mutational processes, consider leaving these samples out or using the raw attributions. You should also leave out the TGS samples, which in this analysis are treated as having 0 mutations.)
* **trinuc_rates**: Inferred relative rates of mutation, produced by matrix-multiplying biological_weights and signature definitions. (These rates will not equal the empirical rates seen in the data.)

While we're here, MutationalPatterns has some nice plot functions that we can use. For example, we can plot the mean SNV profile for each BRCA receptor subtype. (We would not want to include TGS samples in this plot since cancer hotspot mutations are not reflective of overall mutational processes, but since our TGS samples lack receptor_status information, they will be left out without having to specifically exclude them.)

```{r eval = T, include = F}
snv_counts = readRDS(system.file("tutorial/BRCA_snv_counts.rds", package = 'cancereffectsizeR'))
cesa = list(samples = readRDS(system.file("tutorial/BRCA_cesa_samples.rds", package = 'cancereffectsizeR')))
```

```{r}
snv_counts = cesa$mutational_signatures$snv_counts
```
```{r eval = T}
# Counts look like this:
snv_counts[1:5, 1:5]

# We'll sum up the counts by group
summed_snv_by_group = data.table()
receptor_groups = unique(na.omit(cesa$samples$receptor_status))
for (grp in receptor_groups) {
  curr_samples = cesa$samples[grp, Unique_Patient_Identifier, on = 'receptor_status']
  curr_snv_sum = rowSums(snv_counts[, curr_samples])
  summed_snv_by_group[, (grp) := curr_snv_sum]
}
summed_snv_by_group = as.matrix(summed_snv_by_group)
rownames(summed_snv_by_group) = rownames(snv_counts)
MutationalPatterns::plot_96_profile(summed_snv_by_group)
```

## Gene mutation rates
Next, we'll use `gene_mutation_rates()` to estimate regional rates of mutation in the absence of selection. We'll use the method provided in the dNdScv package, which uses dN/dS ratios and mutation rate covariates. Our refset has pre-computed covariates for a variety of tissue types. As with mutational processes, this analysis will not use the TGS samples, but the calculated rates will be assumed to hold for them.
```{r}
cesa = gene_mutation_rates(cesa, covariates = ces.refset.hg38$covariates$breast)
```

Side note: If we had multiple tissue types in the analysis, we could call gene_mutation_rates() multiple times using the `samples` argument to specify sample groups, with appropriate covariates for each tissue type. Similar functionality is available in `trinuc_mutation_rates()`.

## Selection inference
The combination of neutral gene mutation rates and sample-specific rates of trinucleotide mutation allow use to estimate the neutral rate of any somatic substitution in any patient's tumor sample.

(To be continued. Check back in a week for the rest!)
