#' Annotate variants
#' 
#' Annotates CESAnalysis MAF data with reference genome and gene data; called by load_maf
#'
#' @param refset CES reference data set (e.g., from the ces.refset.hg19 data package)
#' @param variants MAF-like data.table of variants (e.g., as generated by preload_maf())
#' @keywords internal
annotate_variants <- function(refset = NULL, variants = NULL) {
  if (! is(refset, "environment")) {
    stop("refset should be class environment (if you gave a refset package name, load the package first and try again).")
  }
  if (! is(variants, "data.table")) {
    stop("variants should be a data.table.")
  }
  
  # For now, return empty data.table if no variants to annotate
  if (variants[, .N] == 0) {
    return(list(amino_acid_change = aac_annotation_template, sbs = sbs_annotation_template,
                dbs_codon_change = dbs_codon_change_template, dbs = dbs_annotation_template,
                aac_sbs_key = aac_sbs_key_template, aac_dbs_key = aac_dbs_key_template))
  }
  
  if (! all(c("Chromosome", "Start_Position", "Reference_Allele", "Tumor_Allele") %in% names(variants))) {
    stop("Invalid variants input. Should be MAF-like data.table, as from preload_maf().")
  }
  
  # If variant_type / variant_id are already present, we will trust
  if (! all(c('variant_type', 'variant_id') %in% names(variants))) {
    variants = identify_maf_variants(variants)
  }
  
  # Could just take rows with non-duplicated variant ID, except illegal variants have NA IDs.
  variants = unique(variants[, .(Chromosome, Start_Position, Reference_Allele, Tumor_Allele, variant_type, variant_id)])
  
  sbs = variants[variant_type == "sbs"]
  annotated_sbs = annotate_sbs(sbs = sbs, refset = refset)
  
  dbs = variants[variant_type == 'dbs']
  annotated_dbs = annotate_dbs(dbs = dbs, refset = refset)
  return(c(annotated_sbs, annotated_dbs))
}


annotate_dbs = function(dbs, refset) {
  results = list(dbs = dbs_annotation_template, dbs_codon_change = dbs_codon_change_template, 
                 aac_dbs_key = aac_dbs_key_template)
  if(dbs[, .N] == 0) {
    return(results)
  }
  
  final_codon_change = copy(dbs_codon_change_template)[, -"variant_name"] # will add this back later
  final_dbs = copy(dbs_annotation_template)[, -"cosmic_dbs_class"] # same
  while(dbs[, .N] > 0) {
    dbs[, sbs1 := paste0(Chromosome, ':', Start_Position, '_', substr(Reference_Allele, 1, 1),
                         '>', substr(Tumor_Allele, 1, 1))]
    
    dbs[, sbs2 := paste0(Chromosome, ':', Start_Position + 1, '_', substr(Reference_Allele, 2, 2),
                         '>', substr(Tumor_Allele, 2, 2))]
    
    anno_out = list()
    for (col in c('sbs1', 'sbs2')) {
      dt = as.data.table(tstrsplit(dbs[[col]], split = '[:_>]'))
      setnames(dt, c("Chromosome", "Start_Position", "Reference_Allele", "Tumor_Allele"))
      dt[, Start_Position := as.numeric(Start_Position)]
      dt[, c("variant_type", "variant_id") := .('sbs', dbs[[col]])]
      anno_out[[col]] = annotate_sbs(dt[!duplicated(variant_id)], refset)
    }
    setnames(dbs, 'variant_id', 'dbs_id')
    
    # We use sbs1/sbs2 to refer to the first and second substituted bases in a DBS.
    # Each of these may associated with one or more sbs AACs.
    # We'll merge in all such associations from aac_sbs_key.
    # sbs1/sbs2 that have no AAC will be included with NA values in the columns taken from aac_sbs_key.
    sbs1_aac_hits = merge.data.table(unique(dbs[, .(sbs_id = sbs1, dbs_id)]),
                                     anno_out$sbs1$aac_sbs_key, 
                                     by = 'sbs_id', all.x = T, allow.cartesian = TRUE)
    sbs2_aac_hits = merge.data.table(unique(dbs[, .(sbs_id = sbs2, dbs_id)]),
                                     anno_out$sbs2$aac_sbs_key, 
                                     by = 'sbs_id', all.x = T, allow.cartesian = TRUE)
    
    # Merge in annotations for each AAC, keeping sbs1 and sbs2 annotations separate.
    sbs1_aac_anno = anno_out$sbs1$amino_acid_change[, .(aac_id, gene, aa_ref, aa_pos, aa_alt, coding_seq, strand, pid, nt1_pos, nt2_pos, nt3_pos)]
    sbs2_aac_anno = anno_out$sbs2$amino_acid_change[, .(aac_id, gene, aa_ref, aa_pos, aa_alt, coding_seq, strand, pid, nt1_pos, nt2_pos, nt3_pos)]
    
    sbs1_aac_hits = merge.data.table(sbs1_aac_hits, sbs1_aac_anno, by = 'aac_id', all.x = TRUE)
    sbs2_aac_hits = merge.data.table(sbs2_aac_hits, sbs2_aac_anno, by = 'aac_id', all.x = TRUE)
    
    # Create combined records for each DBS. Every possible combination of sbs1/sbs2 AACs for each DBS gets a row.
    # Note: We're not getting records for the case of two codon changes on separate PIDs.
    no_aac = merge.data.table(sbs1_aac_hits[is.na(pid)], sbs2_aac_hits[is.na(pid)], by = 'dbs_id', 
                              suffixes = c('.sbs1', '.sbs2'))
    sbs1_aac = merge.data.table(sbs1_aac_hits[! is.na(pid)], sbs2_aac_hits[is.na(pid)], by = 'dbs_id', 
                                suffixes = c('.sbs1', '.sbs2'))
    sbs2_aac = merge.data.table(sbs1_aac_hits[is.na(pid)], sbs2_aac_hits[! is.na(pid)], by = 'dbs_id',
                                suffixes = c('.sbs1', '.sbs2'))
    both_aac = merge.data.table(sbs1_aac_hits[! is.na(pid)], sbs2_aac_hits[! is.na(pid)], 
                                by = c('dbs_id', 'pid'), all = FALSE, 
                                suffixes = c('.sbs1', '.sbs2'))
    dbs_anno = rbindlist(list(no_aac, sbs1_aac, sbs2_aac, both_aac) , fill = T)
    
    # Merge in sbs-level annotations.
    sbs1_sbs_anno = anno_out$sbs1$sbs[, .(sbs_id, chr, pos, ref, alt, intergenic, essential_splice)]
    sbs2_sbs_anno = anno_out$sbs2$sbs[, .(sbs_id, chr, pos, ref, alt, intergenic, essential_splice)]
    setnames(sbs1_sbs_anno, paste0(names(sbs1_sbs_anno), '.sbs1'))
    setnames(sbs2_sbs_anno, paste0(names(sbs2_sbs_anno), '.sbs2'))
    dbs_anno = merge.data.table(dbs_anno, sbs1_sbs_anno, by = 'sbs_id.sbs1', all.x = T)
    dbs_anno = merge.data.table(dbs_anno, sbs2_sbs_anno, by = 'sbs_id.sbs2', all.x = T)
    
    # Produce DBS table
    dbs_anno[dbs, c("chr", "pos", "ref", "alt") := 
               .(Chromosome, Start_Position, Reference_Allele, Tumor_Allele), on = 'dbs_id']
    
    dbs_anno[, intergenic := intergenic.sbs1 == TRUE & intergenic.sbs2 == TRUE]
    dbs_anno[, essential_splice := essential_splice.sbs1 == TRUE | essential_splice.sbs2 == TRUE]
    
    # Codon (or codon pair) genomic start/end. NA when there is no codon.
    dbs_anno[! (is.na(aac_id.sbs1) & is.na(aac_id.sbs2)), start := apply(.SD, 1, min, na.rm = TRUE),
             .SDcols = c("nt1_pos.sbs1", "nt2_pos.sbs1", "nt3_pos.sbs1", "nt1_pos.sbs2", 
                                                      "nt2_pos.sbs2", "nt3_pos.sbs2")]
    dbs_anno[! (is.na(aac_id.sbs1) & is.na(aac_id.sbs2)), end := apply(.SD, 1, max, na.rm = TRUE),
             .SDcols = c("nt1_pos.sbs1", "nt2_pos.sbs1", "nt3_pos.sbs1", "nt1_pos.sbs2", 
                         "nt2_pos.sbs2", "nt3_pos.sbs2")]
    
    # DBS table is for non-AAC information (analogous to the sbs annotation table)
    # cosmic_dbs_class will get filled it later
    final_dbs = unique(rbind(final_dbs, dbs_anno[, .(dbs_id, chr, pos, ref, alt, intergenic, essential_splice)]))
    
    
    # Partition dbs_anno into 5 cases
    left_coding = dbs_anno[! is.na(aac_id.sbs1) & is.na(aac_id.sbs2)]
    right_coding = dbs_anno[is.na(aac_id.sbs1) & ! is.na(aac_id.sbs2)]
    neither_coding = dbs_anno[is.na(aac_id.sbs1) & is.na(aac_id.sbs2)]
    codon_change = dbs_anno[aa_pos.sbs1 == aa_pos.sbs2]
    two_codon = dbs_anno[abs(aa_pos.sbs1 - aa_pos.sbs2) == 1]
    
    if(two_codon[, .N] > 0) {
      two_codon[, coding_seq := fcase(aa_pos.sbs1 < aa_pos.sbs2, 
                                      paste0(coding_seq.sbs1, coding_seq.sbs2),
                                      default = paste0(coding_seq.sbs2, coding_seq.sbs1))]
      two_codon[, enclosing_seq := fcase(aa_pos.sbs1 < aa_pos.sbs2, 
                                         paste0(substr(coding_seq.sbs1, 1, 2), substr(coding_seq.sbs2, 2, 3)),
                                         default =  paste0(substr(coding_seq.sbs2, 1, 2), substr(coding_seq.sbs1, 2, 3)))]
      
      two_codon[aa_alt.sbs1 == 'STOP', aa_alt.sbs1 := '*']
      two_codon[aa_alt.sbs1 != '*', aa_alt.sbs1 := seqinr::a(aa_alt.sbs1)]
      two_codon[aa_alt.sbs2 == 'STOP', aa_alt.sbs2 := '*']
      two_codon[aa_alt.sbs2 != '*', aa_alt.sbs2 := seqinr::a(aa_alt.sbs2)]
      
      two_codon[aa_ref.sbs1 == 'STOP', aa_ref.sbs1 := '*']
      two_codon[aa_ref.sbs1 != '*', aa_ref.sbs1 := seqinr::a(aa_ref.sbs1)]
      two_codon[aa_ref.sbs2 == 'STOP', aa_ref.sbs2 := '*']
      two_codon[aa_ref.sbs2 != '*', aa_ref.sbs2 := seqinr::a(aa_ref.sbs2)]
      
      two_codon[, aa_alt := fcase(aa_pos.sbs1 < aa_pos.sbs2, paste0(aa_alt.sbs1, aa_alt.sbs2),
                                  default = paste0(aa_alt.sbs2, aa_alt.sbs1))]
      two_codon[, aa_ref := fcase(aa_pos.sbs1 < aa_pos.sbs2, paste0(aa_ref.sbs1, aa_ref.sbs2),
                                  default = paste0(aa_ref.sbs2, aa_ref.sbs1))]
      two_codon[, aa_pos := pmin(aa_pos.sbs1, aa_pos.sbs2)]
      
      # Use the two_codon_dbs_key to get all dinucleotides that produce the aa_alt given the aa_alt and enclosing_seq
      double_codon_change = two_codon[, .(chr, pid, essential_splice, strand = strand.sbs1, gene = gene.sbs1, aa_ref, 
                                          aa_pos = aa_pos, coding_seq, pos, start, end, ref,
                                          aa_alt = aa_alt, alt = two_codon_dbs_key[[enclosing_seq]][[aa_alt]]), by = .I]
      
      # For negative-stranded coding sequence, reverse compelement to get genomic alt allele
      double_codon_change[strand == -1, alt := as.character(Biostrings::reverseComplement(DNAStringSet(alt)))]
      
      # Remove records that don't count as DBS (due to one or both ref/alt bases matching)
      double_codon_change = double_codon_change[substr(ref, 1, 1) != substr(alt, 1, 1) & substr(ref, 2, 2) != substr(alt, 2, 2)]
      
      
      double_codon_change[, aachange := paste0(aa_ref, aa_pos, aa_alt)]
      double_codon_change[, dbs_aac_id := paste0(gene, '_', aachange, '_', pid)]
      double_codon_change[, dbs_id := paste0(chr, ':', pos, '_', ref, '>', alt)]
      new_dbs_from_double_codon = double_codon_change[! dbs_id %in% final_dbs$dbs_id, .(Chromosome = chr, Start_Position = pos, Reference_Allele = ref, 
                                                                                        Tumor_Allele = alt, variant_id = dbs_id)]
      double_codon_change = double_codon_change[, .SD, .SDcols = c('dbs_id', setdiff(names(dbs_codon_change_template), 'variant_name'))]
      final_codon_change = unique(rbind(final_codon_change, double_codon_change, fill =T))
    } else {
      new_dbs_from_double_codon = data.table()
    }
    
    
    # left-coding, right essential splice: X. > spl
    # right-coding, left essential splice: X.>spl
    # neither-coding: essential splice
    # codon change: essential splice possible
    # 
    # Sanity check (remove later)
    if(sum(sapply(list(left_coding, right_coding, neither_coding, codon_change, two_codon), nrow)) -
       dbs_anno[, .N] != 0) {
      stop('Failed to classify some doublet mutations into distinct cases.')
    }
    
    if(codon_change[, .N] > 0) {
      # Reduce codon_change to what's needed.
      codon_change = codon_change[, .(dbs_id, chr, start, end, pos, ref, alt, pid, essential_splice, intergenic, 
                                      strand = strand.sbs1, gene = gene.sbs1, aa_ref = aa_ref.sbs1,
                                      aa_pos = aa_pos.sbs1, nt1_pos = nt1_pos.sbs1, nt2_pos = nt2_pos.sbs1,
                                      nt3_pos = nt3_pos.sbs1, coding_seq = coding_seq.sbs1)]
      
      # Codon sequence is reverse complement of genomic sequence for negative strand genes.
      # Get doublet alt sequence.
      codon_change[, sbs1_codon_pos := mapply(function(pos, nt1_pos, nt2_pos, nt3_pos)
      { which(c(nt1_pos, nt2_pos, nt3_pos) == pos) }, pos, nt1_pos, nt2_pos, nt3_pos)]
      codon_change[, sbs2_codon_pos := sbs1_codon_pos + 1 * strand]
      
      codon_change[, insert_pos := pmin(sbs1_codon_pos, sbs2_codon_pos)]
      codon_change[strand == 1, new_bases := alt]
      codon_change[strand == -1, new_bases := as.character(reverseComplement(DNAStringSet(alt)))]
      codon_change[, alt_seq := coding_seq]
      substr(codon_change$alt_seq, codon_change$insert_pos, codon_change$insert_pos + 1) = codon_change$new_bases
      codon_change[, aa_alt := as.character(Biostrings::translate(DNAStringSet(alt_seq), no.init.codon = TRUE))]
      codon_change[, c('sbs1_codon_pos', 'sbs2_codon_pos', 'insert_pos', 'new_bases', 'alt_seq') := NULL]
      codon_change[aa_ref == 'STOP', short_ref := '*']
      codon_change[aa_ref != 'STOP', short_ref := seqinr::a(aa_ref)]
      codon_change[, aachange := paste0(short_ref, aa_pos, aa_alt)]
      codon_change[, short_alt := aa_alt]
      codon_change[, aa_alt := seqinr::aaa(aa_alt)]
      codon_change[aa_alt == 'Stp', aa_alt := 'STOP']
      
      codon_change[, dbs_aac_id := paste0(gene, '_', aachange, '.dbs_', pid)]
      
      # left_coding[, c(aac_cols_to_fill) := .SD, .SDcols =  aac_source_cols]
      # 
      # 
      # left_coding[strand == 1, aachange := paste0(seqinr::a(aa_ref), '.')]
      # left_coding[strand == -1, aachange := paste0('.', seqinr::a(aa_ref))]
      # 
      # 
      # left_coding[, aa_ref := paste0(aa_ref, '.')]
      # left_coding[, aa_alt := paste0(aa_alt, '.')]
      # left_coding[, aachange := paste0(seqinr::a(aa_ref), aa_pos, seqinr::a(aa_alt))]
      
      
      # build other DBS IDs for each DBS and annotate these
      # leading coding chars get same position
      codon_to_solve = unique(codon_change[, .(coding_seq, aa_alt)])     
      all_dbs = mapply('[[', codon_dbs_to_aa[codon_to_solve$coding_seq], codon_to_solve$aa_alt, SIMPLIFY = FALSE)                                   
      
      # Get DBS covering positions 1,2 and 2,3 in coding sequence.
      get_dbs = function(codon_start_pos) {
        nt_records = copy(codon_to_solve)
        nt_records[, nt_dbs := lapply(all_dbs, '[[', codon_start_pos)]
        nt_records = nt_records[sapply(nt_dbs, length) > 0]
        
        # On small data sets, there may be no possible AAC DBS for a given coding position
        if(nt_records[, .N] == 0) {
          return(data.table())
        }
        nt_records[, tmp := 1:.N]
        nt_records = nt_records[, .(coding_seq, aa_alt, nt_alt = unlist(nt_dbs)), by = 'tmp']
        
        # nomatch to leave out codon changes that can't be caused at the current codon positions (1,2 or 2,3)
        # allow.cartesian because each original codon change may have multiple equivalent DBS in nt_records
        nt_records = nt_records[codon_change, on = c('coding_seq', 'aa_alt'), nomatch = NULL, allow.cartesian = T]
        
        # The proposed coding_seq 
        nt_records[strand == 1, alt := nt_alt]
        nt_records[strand == -1, alt := as.character(reverseComplement(DNAStringSet(nt_alt)))]
        nt_records = unique(nt_records)
        
        if(codon_start_pos == 1) {
          nt_records[, pos := pmin(nt1_pos, nt2_pos)]
        } else if (codon_start_pos == 2) {
          nt_records[, pos := pmin(nt2_pos, nt3_pos)]
        }
        nt_records[, new_ref := fcase(strand == 1, substr(coding_seq, codon_start_pos, codon_start_pos + 1),
                                      default = substr(as.character(Biostrings::reverseComplement(DNAStringSet(coding_seq))),
                                                       3 - codon_start_pos, 4 - codon_start_pos))]
        
        nt_records[, dbs_id := paste0(chr, ':', pos, '_', new_ref, '>', alt)]
        nt_records$ref = nt_records$new_ref
        nt_records[, dbs_aac_id := paste0(gene, '_', aachange, '_', pid)]
        return(nt_records)
      }
      
      nt_records = rbind(get_dbs(codon_start_pos = 1),
                         get_dbs(codon_start_pos = 2))
      
      # New DBS could have additional associated DBS AAC that should also be annotated
      new_dbs = unique(nt_records[, .SD, .SDcols = names(final_dbs)][! dbs_id %in% final_dbs$dbs_id])
      codon_change[, let(aa_ref = short_ref, aa_alt = short_alt)]
      codon_change[, c("intergenic", "ref", "alt", "pos", "short_alt", "short_ref") := NULL]
      
      # Redundancy (more than one dbs_id listing per dbs_aac_id) maintained until end of annotation to ensure
      # that dbs_id discovered during coding annotation get annotated, too.
      final_codon_change = unique(rbind(final_codon_change, codon_change, fill = T)) 
      
      # Case 2: Different codons (or one on-codon, one off), either sbs splice-disrupting.
      dbs_anno[, essential_splice := essential_splice.sbs1 == T | essential_splice.sbs2 == T]
      which_noncoding = dbs_anno[is.na(aac_id.sbs1) & is.na(aac_id.sbs2), which = T]
      noncoding_dbs = dbs_anno[which_noncoding]
      dbs_anno = dbs_anno[! which_noncoding]
      dbs = new_dbs[, .(Chromosome = chr, Start_Position = pos, Reference_Allele = ref, 
                        Tumor_Allele = alt, variant_id = dbs_id)]
    } else {
      dbs = data.table() # In other words, there is nothing left to annotate if there are no new codon-changing DBS
    }
    dbs = rbind(dbs, new_dbs_from_double_codon)
  }
  
  
  # cosmic_dbs_classes (in sysdata) contains the correct 78 COSMIC DBS classes.
  # Any initially assigned classes that are invalid need to be reverse complemented.
  final_dbs[, cosmic_dbs_class := paste0(ref, '>', alt)]
  final_dbs[! cosmic_dbs_class %in% cosmic_dbs_classes, 
            cosmic_dbs_class := paste0(as.character(reverseComplement(DNAStringSet(ref))),
                                       '>',
                                       as.character(reverseComplement(DNAStringSet(alt))))]
  
  if (final_codon_change[, .N] > 0) {
    aac_dbs_key = final_codon_change[, .(dbs_aac_id = unique(dbs_aac_id)), by = 'dbs_id']
    final_codon_change$dbs_id = NULL
  } else {
    aac_dbs_key = copy(aac_dbs_key_template)
  }
  final_codon_change = unique(final_codon_change, by = 'dbs_aac_id')
  
  # Don't need these (will be absent anyway when there are no single-codon DBS).
  suppressWarnings(final_codon_change[, c('nt1_pos', 'nt2_pos', 'nt3_pos') := NULL])
  
  final_codon_change[, variant_name := paste0(gene, '_', aachange, '.dbs')] #.dbs
  setcolorder(final_codon_change, 'variant_name')
  
  # BRAF_V600E.dbs ()
  if(! is.null(refset$transcripts)) {
    final_codon_change[refset$transcripts, is_mane := is_mane, on = c(pid = 'protein_id')]
    final_codon_change[is_mane == FALSE, variant_name := paste0(variant_name, ' (', pid, ')')]
    final_codon_change[, is_mane := NULL]
  }
  setkey(final_dbs, 'dbs_id')
  setkey(final_codon_change, 'dbs_aac_id')
  return(list(dbs = final_dbs, dbs_codon_change = final_codon_change, aac_dbs_key = aac_dbs_key))
}


#' Annotates MAF-like table with nearest gene and CDS entries
#' 
#' @param variants MAF-like data.table
#' @param refset CES reference data environment
#' @keywords internal
get_nearest_refset_entries = function(variants, refset) {
  variant_grs = GenomicRanges::makeGRangesFromDataFrame(variants[, .(seqnames = Chromosome, start = Start_Position,
                                                                     end = Start_Position, variant_id, variant_type)], 
                                                        keep.extra.columns = TRUE)
  gr_cds = refset$gr_genes
  
  # Get gene annotations
  ## Note: If RefCDS/gr_cds are transcript-level, the ranges and annotations will refer to transcripts, not genes
  nearest = as.data.table(GenomicRanges::distanceToNearest(variant_grs, gr_cds, select = "all"))
  
  # convert the "subjectHits" index returned by the distanceToNearest function to the corresponding gene name
  refcds_entry_names = GenomicRanges::mcols(gr_cds)["names"][,1]
  nearest[, refcds_entry := refcds_entry_names[subjectHits]]
  
  if("gene" %in% names(GenomicRanges::mcols(gr_cds))) {
    nearest[, gene := gr_cds[subjectHits]$gene]
    nearest[, pid := refcds_entry]
  } else {
    nearest[, gene := refcds_entry]
    genes_to_lookup = unique(nearest$gene)
    pid_lookup = sapply(refset$RefCDS[genes_to_lookup], '[[', 'protein_id')
    nearest[, pid := pid_lookup[gene]]
  }

  
  # Sometimes an sbs overlaps the same CDS region twice due to redundant GRanges.
  # Uniquify to get one row per variant/protein match.
  nearest = unique(nearest, by = c("queryHits", "refcds_entry"))
  
  
  # queryHits column gives sbs table row. Some records have multiple matching entries; combine them into variable-length
  # vector within each sbs table row. Also grab the distance to the first matching refcds entry (distances are always
  # equal on multiple hits, since we asked for the nearest).
  refcds_entries_by_variant_row = setDT(nearest[, .(cds = list(refcds_entry), dist = distance[1], 
                                                    genes = list(unique(gene)), nearest_pid = list(pid)), by = "queryHits"])
  variants[, c("cds", "dist", "genes", "nearest_pid") := refcds_entries_by_variant_row[, .(cds, dist, genes, nearest_pid)]]
  return(variants)
}
