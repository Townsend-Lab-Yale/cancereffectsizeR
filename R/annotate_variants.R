#' Annotate variants
#' 
#' Annotates CESAnalysis MAF data with reference genome and gene data; called by load_maf
#'
#' @param refset CES reference data set (e.g., from the ces.refset.hg19 data package)
#' @param variants MAF-like data.table of variants (e.g., as generated by preload_maf())
#' @keywords internal
annotate_variants <- function(refset = NULL, variants = NULL) {
  if (! is(refset, "environment")) {
    stop("refset should be class environment (if you gave a refset package name, load the package first and try again).")
  }
  if (! is(variants, "data.table")) {
    stop("variants should be a data.table.")
  }
  
  # For now, return empty data.table if no variants to annotate
  if (variants[, .N] == 0) {
    return(list(amino_acid_change = data.table(), snv = data.table()))
  }
  
  if (! all(c("Chromosome", "Start_Position", "Reference_Allele", "Tumor_Allele") %in% names(variants))) {
    stop("Invalid variants input. Should be MAF-like data.table, as from preload_maf().")
  }
  
  # If variant_type / variant_id are already present, we will trust
  if (! all(c('variant_type', 'variant_id') %in% names(variants))) {
    variants = identify_maf_variants(variants)
  }
  
  # Could just take rows with non-duplicated variant ID, except illegal variants have NA IDs.
  variants = unique(variants[, .(Chromosome, Start_Position, Reference_Allele, Tumor_Allele, variant_type, variant_id)])
  
  snvs = variants[variant_type == "snv"]
  annotated_snvs = annotate_snvs(snvs = snvs, refset = refset)
  
  dbs = variants[variant_type == 'dbs']
  annotated_dbs = annotate_dbs(dbs = dbs, refset = refset)
  return(c(annotated_snvs, annotated_dbs))
}


annotate_dbs = function(dbs, refset) {
  # TO-DO: switch in templates
  results = list(dbs_codon_change = data.table(), dbs = data.table(), aac_dbs_key = data.table())
  if(dbs[, .N] == 0) {
    return(results)
  }
  
  
  final_codon_change = data.table(dbs_id = character(), chr = character(), pid = character(), 
                                  essential_splice = character(), strand = character(), gene = character(), 
                                  aa_ref = character(), aa_pos = character(), nt1_pos = character(), 
                                  nt2_pos = character(), nt3_pos = character(), coding_seq = character(), 
                                  aa_alt = character(), aachange = character(), dbs_aac_id = character())
  final_dbs = data.table(dbs_id = character(), chr = character(), pos = numeric(), 
                         ref = character(), alt = character(), intergenic = character(), essential_splice = character())
  
  while(dbs[, .N] > 0) {
    dbs[, snv1 := paste0(Chromosome, ':', Start_Position, '_', substr(Reference_Allele, 1, 1),
                         '>', substr(Tumor_Allele, 1, 1))]
    
    dbs[, snv2 := paste0(Chromosome, ':', Start_Position + 1, '_', substr(Reference_Allele, 2, 2),
                         '>', substr(Tumor_Allele, 2, 2))]
    
    anno_out = list()
    for (col in c('snv1', 'snv2')) {
      dt = as.data.table(tstrsplit(dbs[[col]], split = '[:_>]'))
      setnames(dt, c("Chromosome", "Start_Position", "Reference_Allele", "Tumor_Allele"))
      dt[, Start_Position := as.numeric(Start_Position)]
      dt[, c("variant_type", "variant_id") := .('snv', dbs[[col]])]
      anno_out[[col]] = annotate_snvs(dt[!duplicated(variant_id)], refset)
    }
    setnames(dbs, 'variant_id', 'dbs_id')
    
    # Each nucleotide in DBS may be associated with one or more SNV AACs.
    # Get all pairings for each nucleotide, which we'll call SNV1 and SNV2.
    # Nucleotides with no AAC matches will also be included with NA annotations.
    snv1_aac_hits = anno_out$snv1$aac_snv_key[dbs[, .(snv1, dbs_id)], on = c(snv_id = 'snv1')]
    snv2_aac_hits = anno_out$snv2$aac_snv_key[dbs[, .(snv2, dbs_id)], on = c(snv_id = 'snv2')]
    
    # Merge in annotations for each AAC, keeping SNV1 and SNV2 annotations separate.
    snv1_aac_anno = anno_out$snv1$amino_acid_change[, .(aac_id, gene, aa_ref, aa_pos, aa_alt, coding_seq, strand, pid, nt1_pos, nt2_pos, nt3_pos)]
    snv2_aac_anno = anno_out$snv2$amino_acid_change[, .(aac_id, gene, aa_ref, aa_pos, aa_alt, coding_seq, strand, pid, nt1_pos, nt2_pos, nt3_pos)]
    
    snv1_aac_hits = merge.data.table(snv1_aac_hits, snv1_aac_anno, by = 'aac_id', all.x = TRUE)
    snv2_aac_hits = merge.data.table(snv2_aac_hits, snv2_aac_anno, by = 'aac_id', all.x = TRUE)
    
    # Create combined records for each DBS. Every possible combination of SNV1/SNV2 AACs for each DBS gets a row.
    # Note: We're not getting records for the case of two codon changes on separate PIDs.
    no_aac = merge.data.table(snv1_aac_hits[is.na(pid)], snv2_aac_hits[is.na(pid)], by = 'dbs_id', 
                              suffixes = c('.snv1', '.snv2'))
    snv1_aac = merge.data.table(snv1_aac_hits[! is.na(pid)], snv2_aac_hits[is.na(pid)], by = 'dbs_id', 
                                suffixes = c('.snv1', '.snv2'))
    snv2_aac = merge.data.table(snv1_aac_hits[is.na(pid)], snv2_aac_hits[! is.na(pid)], by = 'dbs_id',
                                suffixes = c('.snv1', '.snv2'))
    both_aac = merge.data.table(snv1_aac_hits[! is.na(pid)], snv2_aac_hits[! is.na(pid)], 
                                by = c('dbs_id', 'pid'), all = FALSE, 
                                suffixes = c('.snv1', '.snv2'))
    dbs_anno = rbindlist(list(no_aac, snv1_aac, snv2_aac, both_aac) , fill = T)
    
    # Merge in SNV-level annotations.
    snv1_snv_anno = anno_out$snv1$snv[, .(snv_id, chr, pos, ref, alt, intergenic, essential_splice)]
    snv2_snv_anno = anno_out$snv2$snv[, .(snv_id, chr, pos, ref, alt, intergenic, essential_splice)]
    setnames(snv1_snv_anno, paste0(names(snv1_snv_anno), '.snv1'))
    setnames(snv2_snv_anno, paste0(names(snv2_snv_anno), '.snv2'))
    dbs_anno = merge.data.table(dbs_anno, snv1_snv_anno, by = 'snv_id.snv1', all.x = T)
    dbs_anno = merge.data.table(dbs_anno, snv2_snv_anno, by = 'snv_id.snv2', all.x = T)
    
    
    # Produce DBS table
    dbs_anno[dbs, c("chr", "pos", "ref", "alt") := 
               .(Chromosome, Start_Position, Reference_Allele, Tumor_Allele), on = 'dbs_id']
    
    dbs_anno[, intergenic := intergenic.snv1 == TRUE & intergenic.snv2 == TRUE]
    dbs_anno[, essential_splice := essential_splice.snv1 == TRUE | essential_splice.snv2 == TRUE]
    
    # DBS table is for non-AAC information (analogous to the SNV annotation table)
    final_dbs = unique(rbind(final_dbs, dbs_anno[, .(dbs_id, chr, pos, ref, alt, intergenic, essential_splice)]))
    
    
    # Partition dbs_anno into 5 cases
    left_coding = dbs_anno[! is.na(aac_id.snv1) & is.na(aac_id.snv2)]
    right_coding = dbs_anno[is.na(aac_id.snv1) & ! is.na(aac_id.snv2)]
    neither_coding = dbs_anno[is.na(aac_id.snv1) & is.na(aac_id.snv2)]
    codon_change = dbs_anno[aa_pos.snv1 == aa_pos.snv2]
    two_codon = dbs_anno[abs(aa_pos.snv1 - aa_pos.snv2) == 1]
    
    
    ## 
    # left-coding, right essential splice: X. > spl
    # right-coding, left essential splice: X.>spl
    # neither-coding: essential splice
    # codon change: essential splice possible
    # 
    
    # Sanity check (remove later)
    if(sum(sapply(list(left_coding, right_coding, neither_coding, codon_change, two_codon), nrow)) -
       dbs_anno[, .N] != 0) {
      stop('Failed to classify some doublet mutations into distinct cases.')
    }
    
    

    if(codon_change[, .N] > 0) {
      # Reduce codon_change to what's needed.
      codon_change = codon_change[, .(dbs_id, chr, pos, ref, alt, pid, essential_splice, intergenic, 
                                      strand = strand.snv1, gene = gene.snv1, aa_ref = aa_ref.snv1,
                                      aa_pos = aa_pos.snv1, nt1_pos = nt1_pos.snv1, nt2_pos = nt2_pos.snv1,
                                      nt3_pos = nt3_pos.snv1, coding_seq = coding_seq.snv1)]
      
      # Codon sequence is reverse complement of genomic sequence for negative strand genes.
      # Get doublet alt sequence.
      codon_change[, snv1_codon_pos := mapply(function(pos, nt1_pos, nt2_pos, nt3_pos)
      { which(c(nt1_pos, nt2_pos, nt3_pos) == pos) }, pos, nt1_pos, nt2_pos, nt3_pos)]
      codon_change[, snv2_codon_pos := snv1_codon_pos + 1 * strand]
      
      codon_change[, insert_pos := pmin(snv1_codon_pos, snv2_codon_pos)]
      codon_change[strand == 1, new_bases := alt]
      codon_change[strand == -1, new_bases := as.character(reverseComplement(DNAStringSet(alt)))]
      codon_change[, alt_seq := coding_seq]
      substr(codon_change$alt_seq, codon_change$insert_pos, codon_change$insert_pos + 1) = codon_change$new_bases
      codon_change[, aa_alt := as.character(Biostrings::translate(DNAStringSet(alt_seq), no.init.codon = TRUE))]
      codon_change[, c('snv1_codon_pos', 'snv2_codon_pos', 'insert_pos', 'new_bases', 'alt_seq') := NULL]
      codon_change[aa_ref == 'STOP', short_ref := '*']
      codon_change[aa_ref != 'STOP', short_ref := seqinr::a(aa_ref)]
      codon_change[, aachange := paste0(short_ref, aa_pos, aa_alt)]
      codon_change[, short_ref := NULL]
      codon_change[, aa_alt := seqinr::aaa(aa_alt)]
      codon_change[aa_alt == 'Stp', aa_alt := 'STOP']
      codon_change[, dbs_aac_id := paste0(gene, '_', aachange, '_', pid)]
      
      # left_coding[, c(aac_cols_to_fill) := .SD, .SDcols =  aac_source_cols]
      # 
      # 
      # left_coding[strand == 1, aachange := paste0(seqinr::a(aa_ref), '.')]
      # left_coding[strand == -1, aachange := paste0('.', seqinr::a(aa_ref))]
      # 
      # 
      # left_coding[, aa_ref := paste0(aa_ref, '.')]
      # left_coding[, aa_alt := paste0(aa_alt, '.')]
      # left_coding[, aachange := paste0(seqinr::a(aa_ref), aa_pos, seqinr::a(aa_alt))]
      
      
      # build other DBS IDs for each DBS and annotate these
      # leading coding chars get same posit
      codon_to_solve = unique(codon_change[, .(coding_seq, aa_alt)])     
      all_dbs = mapply('[[', codon_dbs_to_aa[codon_to_solve$coding_seq], codon_to_solve$aa_alt, SIMPLIFY = FALSE)                                   
      
      # Get DBS covering positions 1,2 and 2,3 in coding sequence.
      get_dbs = function(codon_start_pos) {
        nt_records = copy(codon_to_solve)
        nt_records[, nt_dbs := lapply(all_dbs, '[[', codon_start_pos)]
        nt_records = nt_records[sapply(nt_dbs, length) > 0]
        
        # On small data sets, there may be no possible AAC DBS for a given coding position
        if(nt_records[, .N] == 0) {
          return(data.table())
        }
        nt_records[, tmp := 1:.N]
        nt_records = nt_records[, .(coding_seq, aa_alt, nt_alt = unlist(nt_dbs)), by = 'tmp']
        
        # nomatch to leave out codon changes that can't be caused at the current codon positions (1,2 or 2,3)
        # allow.cartesian because each original codon change may have multiple equivalent DBS in nt_records
        nt_records = nt_records[codon_change, on = c('coding_seq', 'aa_alt'), nomatch = NULL, allow.cartesian = T]
        
        nt_records[strand == 1, alt := nt_alt]
        nt_records[strand == -1, alt := as.character(reverseComplement(DNAStringSet(nt_alt)))]
        nt_records = unique(nt_records)
        
        if(codon_start_pos == 1) {
          nt_records[, pos := pmin(nt1_pos, nt2_pos)]
        } else if (codon_start_pos == 2) {
          nt_records[, pos := pmin(nt2_pos, nt3_pos)]
        }
        nt_records[, dbs_id := paste0(chr, ':', pos, '_', ref, '>', alt)]
        nt_records[, dbs_aac_id := paste0(gene, '_', aachange, '_', pid)]
        return(nt_records)
      }
      
      nt_records = rbind(get_dbs(codon_start_pos = 1),
                         get_dbs(codon_start_pos = 2))
      
      # New DBS could have additional associated DBS AAC that should also be annotated
      new_dbs = unique(nt_records[, .SD, .SDcols = names(final_dbs)][! dbs_id %in% final_dbs$dbs_id])
      
      codon_change[, c("intergenic", "ref", "alt", "pos") := NULL]
      final_codon_change = unique(rbind(final_codon_change, codon_change))
      
      # Case 2: Different codons (or one on-codon, one off), wither SNV splice-disrupting.
      dbs_anno[, essential_splice := essential_splice.snv1 == T | essential_splice.snv2 == T]
      which_noncoding = dbs_anno[is.na(aac_id.snv1) & is.na(aac_id.snv2), which = T]
      noncoding_dbs = dbs_anno[which_noncoding]
      dbs_anno = dbs_anno[! which_noncoding]
      
      dbs = new_dbs[, .(Chromosome = chr, Start_Position = pos, Reference_Allele = ref, 
                        Tumor_Allele = alt, variant_id = dbs_id)]
    } else {
      dbs = data.table() # In other words, there is nothing left to annotate if there are no new codon-changing DBS
    }
  }
  
  # cosmic_dbs_classes (in sysdata) contains the correct 78 COSMIC DBS classes.
  # Any initially assigned classes that are invalid need to be reverse complemented.
  final_dbs[, cosmic_dbs_class := paste0(ref, '>', alt)]
  final_dbs[! cosmic_dbs_class %in% cosmic_dbs_classes, 
            cosmic_dbs_class := paste0(as.character(reverseComplement(DNAStringSet(ref))),
                                       '>',
                                       as.character(reverseComplement(DNAStringSet(alt))))]
  aac_dbs_key = final_codon_change[, .(dbs_aac_id = unique(dbs_aac_id), 
                                       multi_anno_site = uniqueN(dbs_aac_id) > 1), by = 'dbs_id']
  
  final_codon_change$dbs_id = NULL
  return(list(dbs_codon_change = final_codon_change, dbs = final_dbs, aac_dbs_key = aac_dbs_key))
}


#' Annotates MAF-like table with nearest gene and CDS entries
#' 
#' @param variants MAF-like data.table
#' @param refset CES reference data environment
#' @keywords internal
get_nearest_refset_entries = function(variants, refset) {
  variant_grs = GenomicRanges::makeGRangesFromDataFrame(variants[, .(seqnames = Chromosome, start = Start_Position,
                                                                     end = Start_Position, variant_id, variant_type)], 
                                                        keep.extra.columns = TRUE)
  gr_cds = refset$gr_genes
  
  # Get gene annotations
  ## Note: If RefCDS/gr_cds are transcript-level, the ranges and annotations will refer to transcripts, not genes
  nearest = as.data.table(GenomicRanges::distanceToNearest(variant_grs, gr_cds, select = "all"))
  
  # convert the "subjectHits" index returned by the distanceToNearest function to the corresponding gene name
  refcds_entry_names = GenomicRanges::mcols(gr_cds)["names"][,1]
  nearest[, refcds_entry := refcds_entry_names[subjectHits]]
  
  if("gene" %in% names(GenomicRanges::mcols(gr_cds))) {
    nearest[, gene := gr_cds[subjectHits]$gene]
    nearest[, pid := refcds_entry]
  } else {
    nearest[, gene := refcds_entry]
    genes_to_lookup = unique(nearest$gene)
    pid_lookup = sapply(refset$RefCDS[genes_to_lookup], '[[', 'protein_id')
    nearest[, pid := pid_lookup[gene]]
  }
  
  # Sometimes an SNV overlaps the same CDS region twice due to redundant GRanges.
  # Uniquify to get one row per variant/protein match.
  nearest = unique(nearest, by = c("queryHits", "refcds_entry"))
  
  
  # queryHits column gives snv table row. Some records have multiple matching entries; combine them into variable-length
  # vector within each snv table row. Also grab the distance to the first matching refcds entry (distances are always
  # equal on multiple hits, since we asked for the nearest).
  refcds_entries_by_variant_row = setDT(nearest[, .(cds = list(refcds_entry), dist = distance[1], 
                                                    genes = list(unique(gene)), nearest_pid = list(pid)), by = "queryHits"])
  variants[, c("cds", "dist", "genes", "nearest_pid") := refcds_entries_by_variant_row[, .(cds, dist, genes, nearest_pid)]]
  return(variants)
}
